---
layout: post
title: Java序列化简述
date: 2017-08-24
categories: Java
description: 关于Java的一些小知识总结
published: true
---

最近几天都没有时间写博客了，其实也没有什么好说的。

连续两周加班，效率超级低。天天一点屁事还要做的很晚，关键是对系统实在是不熟悉。真的得花点时间在PIKE上了。

要不然，真的每次做一点界面就是一天，还各种BUG。

**总结一下最近的关键问题：写代码命名不规范，效率低，代码需要多多进行抽象，封装。能复用的尽量多复用。**

因为这段时间敲代码，感觉一直都是停留在很低的一个层次，比CV高一点吧。所以感觉到Java基础还是不扎实。

真觉得自己心比天高，想学这个，想学那个。结果自己吃饭的本事还学的不扎实。

所以打算今后一段之间，空闲的时候，恶补一下Java基础吧。

我总是这样。说出的话与做出的事总有差别。尽量规正吧。

---

言归正传，私以为，当下很多博客都有CV之嫌，那句话怎么说的，**我们不生产代码，我们只是代码的搬运工**

昨天看源码的时候，突然看到了一个经常会被我忽略的东西，serialization序列化。

细想一下，又想不起来了序列化和反序列化的作用。

### 为什么是序列化？

从广义上来说，Java序列化是为了持久化存储对象状态的一种方式。它指的是能够把堆内存中的Java对象数据，通过某种方式存储到磁盘文件中或者传递给其他网络节点(在网络上传输)。

反序列化就是上述步骤相反的过程，把磁盘文件中的对象数据或者把网络节点上的对象数据，恢复成Java对象的过程。

在Java中，提供了序列化以及反序列化的类: java.io.ObjectOutputStream 以及 java.io.ObjectInputStream

下面，看一个序列化的例子，这是一个普通的不能再普通的例子了:

    public class ObjectOutputSteamDemo {
        public static void main(String[] args) {
            File serialization = new File("./serizaliable.txt");
            serializationOperation(serialization);

        }

        /**
        * 
        * method desc 该方法用于进行序列化操作，将Java对象通过流的方式存储在磁盘文件上
        *
        * @param serialization:
        *            存放对象数据的文件
        */
        private static void serializationOperation(File serialization) {
            ObjectOutputStream outputStream = null;
            try {
                outputStream = new ObjectOutputStream(new FileOutputStream(serialization));
                outputStream.writeObject(new Programmer("xiaoxiong", "12345", 18));
                outputStream.flush();
                outputStream.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

为了方便操作，创建了一个实体对象，用于供ObjectOutputSteam进行writeObjec操作：

    public class Programmer {
        private String name;
        private String password;
        private int age;

        public Programmer(String name, String password, int age) {
            super();
            this.name = name;
            this.password = password;
            this.age = age;
        }

        @Override
        public String toString() {
            return "Programmer [name=" + name + ", password=" + password + ", age=" + age + "]";
        }
    }

自行导入类，编译运行，你会发现得到了一个运行时异常错误：

    java.io.NotSerializableException: com.hardstudy.entity.Programmer
        at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1184)
        at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:348)
        at com.hardstudy.io.serialization.ObjectOutputSteamDemo.serializationOperation(ObjectOutputSteamDemo.java:39)
        at com.hardstudy.io.serialization.ObjectOutputSteamDemo.main(ObjectOutputSteamDemo.java:24)

这个异常是怎么出现的呢？ debug一下就不难发现，出现这个异常的原因是**Programmer**类没有实现Serializable接口。

![]({{ site.url }}/assets/Selection_265.png)

稍微变化一下，给我们的实体类增加一个Serializable接口，再次运行，你会发现，成功运行并将内容写入磁盘文件serialization.txt中。不过都是写乱码，这是供反序列化的时候读取的。

![]({{ site.url }}/assets/Selection_266.png)

